# included from src/CGT_UniHeidelberg_2022.jl

export decompose, base_images, perm_by_images, sends_to
const CGT = CGT_UniHeidelberg_2022

""" Implement a method to reconstruct a group element from the images of a given
    basis of a `StabilizerChain`. This function is inverse to `base_images`.
"""
function perm_by_images(sc::StabilizerChain, y::AbstractVector)
    @assert length(y) == CGT.depth(sc)
    @assert length(y) >= 1
    g = one(first(CGT.gens(sc, 1)))

    # proceed in opposite order of element test
    for i in CGT.depth(sc):-1:1
        T = CGT.transversal(sc, i)
        if y[i] ∈ T
            g = g * T[y[i]]
        else
            throw("group element not generated from base image")
        end
    end
    return g
end

""" Obtain uniformly random elements from the group generated by a `StabilizerChain`
"""
function Base.rand(sc::StabilizerChain)
    y = Int64[]
    for i in 1:CGT.depth(sc)
        T = CGT.transversal(sc, i)
        push!(y, rand(T)) # push random base image
    end
    g = perm_by_images(sc, y)
    return g
end

""" Express a group element `g` as a product of transversal elements, each of
    which has been obtained as a product of generators.
"""
function decompose(g::P, gens::AbstractVector{P}) where {P}
    # Use `SchreierTree` to keep track of how transversal elements arose as 
    # products of the original generators.
    G = PermutationGroup{P, CGT.SchreierTree{Int64, P, typeof(^)}}(gens)
    sc = CGT.stabilizer_chain(G)

    # Modified element check which keeps track of transversal elements.
    r = g # the residual
    L = Vector{P}()

    for i in 1:depth(sc)
        T = CGT.transversal(sc, i)
        y = CGT.basis(sc, i)^r

        if y ∉ T
            throw(ArgumentError("element is not in group"))
        else
            Ty, Ty_word = CGT.trace(T, y)
            r = r*inv(Ty)
            for gen in Ty_word
                push!(L, gen)
            end
            
            if r == one(r)
                return L
            end
        end
    end
    throw(ArgumentError("element is not in group"))
end

decompose(g::AbstractPermutation, G::AbstractPermGroup) = decompose(g, CGT.gens(G))
